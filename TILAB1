import tkinter as tk
from tkinter import ttk, messagebox
import numpy as np

class MainApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Теория информации - Выбор варианта")
        self.root.geometry("400x200")
        
        label = tk.Label(root, text="Выберите вариант ввода данных:", font=("Arial", 12))
        label.pack(pady=20)
        
        # Варианты ввода
        self.choice_var = tk.StringVar(value="1")
        
        options = [
            ("1. A, P(B|A)", "1"),
            ("2. B, P(A|B)", "2"), 
            ("3. P(A,B)", "3")
        ]
        
        for text, value in options:
            tk.Radiobutton(root, text=text, variable=self.choice_var, 
                          value=value, font=("Arial", 10)).pack(anchor="w", padx=50)
        
        # Кнопка выбора
        tk.Button(root, text="Выбрать", command=self.open_input_window, 
                 font=("Arial", 10), bg="lightblue").pack(pady=20)
    
    def open_input_window(self):
        choice = self.choice_var.get()
        self.root.withdraw()  # Скрыть главное окно
        
        # Открываем окно выбора размеров для всех вариантов
        SizeSelectionWindow(self.root, choice)

class SizeSelectionWindow:
    """Окно выбора размеров матрицы"""
    def __init__(self, main_root, variant):
        self.main_root = main_root
        self.variant = variant
        self.window = tk.Toplevel(main_root)
        self.window.title("Выбор размеров")
        self.window.geometry("400x300")
        
        tk.Label(self.window, text="Выберите размеры матрицы:", font=("Arial", 12)).pack(pady=20)
        
        # Количество строк (размер A)
        tk.Label(self.window, text="Количество строк (размер ансамбля A):", font=("Arial", 10)).pack(pady=5)
        self.rows_entry = tk.Entry(self.window, width=10)
        self.rows_entry.pack(pady=5)
        self.rows_entry.insert(0, "2")
        
        # Количество столбцов (размер B)
        tk.Label(self.window, text="Количество столбцов (размер ансамбля B):", font=("Arial", 10)).pack(pady=5)
        self.cols_entry = tk.Entry(self.window, width=10)
        self.cols_entry.pack(pady=5)
        self.cols_entry.insert(0, "4")
        
        # Кнопка подтверждения
        tk.Button(self.window, text="Задать размеры матрицы", command=self.create_input_window, 
                 bg="lightgreen", font=("Arial", 10)).pack(pady=20)
        
        tk.Button(self.window, text="Назад", command=self.back).pack()
    
    def create_input_window(self):
        try:
            rows = int(self.rows_entry.get())
            cols = int(self.cols_entry.get())
            
            if rows <= 0 or cols <= 0:
                raise ValueError("Размеры должны быть положительными числами")
                
            self.window.destroy()
            
            # Создаем соответствующее окно ввода с выбранными размерами
            if self.variant == "1":
                InputWindow1(self.main_root, rows, cols)
            elif self.variant == "2":
                InputWindow2(self.main_root, rows, cols)
            elif self.variant == "3":
                InputWindow3(self.main_root, rows, cols)
                
        except ValueError as e:
            messagebox.showerror("Ошибка", f"Некорректные размеры: {str(e)}")
    
    def back(self):
        self.window.destroy()
        self.main_root.deiconify()

class InputWindow1:
    """Окно ввода для варианта 1: A, P(B|A)"""
    def __init__(self, main_root, rows, cols):
        self.main_root = main_root
        self.rows = rows
        self.cols = cols
        self.window = tk.Toplevel(main_root)
        self.window.title("Ввод данных: A, P(B|A)")
        self.window.geometry("700x600")
        
        # Ансамбль A в клеточках
        tk.Label(self.window, text="Ансамбль A (вероятности P(a_i)):", 
                font=("Arial", 10, "bold")).pack(pady=10)
        
        a_frame = tk.Frame(self.window)
        a_frame.pack(pady=5)
        
        self.a_entries = []
        for i in range(rows):
            label = tk.Label(a_frame, text=f"P(a{i+1}):", font=("Arial", 8))
            label.grid(row=0, column=i, padx=5, pady=2)
            
            entry = tk.Entry(a_frame, width=8)
            entry.grid(row=1, column=i, padx=5, pady=2)
            self.a_entries.append(entry)
        
        # Условные вероятности P(B|A)
        tk.Label(self.window, text="Условные вероятности P(B|A):", 
                font=("Arial", 10, "bold")).pack(pady=10)
        
        # Заголовки для B
        matrix_header = tk.Frame(self.window)
        matrix_header.pack(pady=5)
        
        tk.Label(matrix_header, text="", width=8).grid(row=0, column=0)
        for j in range(cols):
            tk.Label(matrix_header, text=f"P(b{j+1}|a_i)", font=("Arial", 8), width=8).grid(row=0, column=j+1)
        
        # Создаем фрейм для матрицы
        matrix_frame = tk.Frame(self.window)
        matrix_frame.pack(pady=5)
        
        self.matrix_entries = []
        for i in range(rows):
            tk.Label(matrix_frame, text=f"P(B|a{i+1}):", font=("Arial", 8)).grid(row=i, column=0, padx=5, pady=2)
            row_entries = []
            for j in range(cols):
                entry = tk.Entry(matrix_frame, width=8)
                entry.grid(row=i, column=j+1, padx=2, pady=2)
                row_entries.append(entry)
            self.matrix_entries.append(row_entries)
        
        tk.Button(self.window, text="Рассчитать", command=self.calculate, bg="lightgreen", font=("Arial", 10)).pack(pady=15)
        tk.Button(self.window, text="Назад", command=self.back).pack()
        
    def calculate(self):
        try:
            # Парсим ансамбль A
            a_probs = []
            for i, entry in enumerate(self.a_entries):
                value = entry.get().strip()
                if not value:
                    raise ValueError(f"Введите вероятность P(a{i+1})")
                a_probs.append(float(value))
            
            if len(a_probs) != self.rows:
                raise ValueError(f"Ожидается {self.rows} значений для A")
            
            # Парсим матрицу условных вероятностей
            cond_probs = []
            for i in range(self.rows):
                row = []
                for j in range(self.cols):
                    value = self.matrix_entries[i][j].get().strip()
                    if not value:
                        raise ValueError(f"Пустое значение в ячейке P(b{j+1}|a{i+1})")
                    row.append(float(value))
                cond_probs.append(row)
            
            # Проверяем корректность данных
            if abs(sum(a_probs) - 1.0) > 0.001:
                raise ValueError(f"Сумма вероятностей A должна быть равна 1 (получено {sum(a_probs):.4f})")
                
            for i, row in enumerate(cond_probs):
                if abs(sum(row) - 1.0) > 0.001:
                    raise ValueError(f"Сумма условных вероятностей для a{i+1} должна быть равна 1 (получено {sum(row):.4f})")
            
            # Вызываем расчетный модуль
            results = calculate_from_variant1(a_probs, cond_probs)
            
            # Показываем результаты
            show_results(results)
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Некорректные данные: {str(e)}")
    
    def back(self):
        self.window.destroy()
        self.main_root.deiconify()

class InputWindow2:
    """Окно ввода для варианта 2: B, P(A|B)"""
    def __init__(self, main_root, rows, cols):
        self.main_root = main_root
        self.rows = rows  # размер A
        self.cols = cols  # размер B
        self.window = tk.Toplevel(main_root)
        self.window.title("Ввод данных: B, P(A|B)")
        self.window.geometry("700x600")
        
        # Ансамбль B в клеточках
        tk.Label(self.window, text="Ансамбль B (вероятности P(b_j)):", 
                font=("Arial", 10, "bold")).pack(pady=10)
        
        b_frame = tk.Frame(self.window)
        b_frame.pack(pady=5)
        
        self.b_entries = []
        for j in range(cols):
            label = tk.Label(b_frame, text=f"P(b{j+1}):", font=("Arial", 8))
            label.grid(row=0, column=j, padx=5, pady=2)
            
            entry = tk.Entry(b_frame, width=8)
            entry.grid(row=1, column=j, padx=5, pady=2)
            self.b_entries.append(entry)
        
        # Условные вероятности P(A|B) - матрица |A| × |B|
        tk.Label(self.window, text="Условные вероятности P(A|B):", 
                font=("Arial", 10, "bold")).pack(pady=10)
        
        # Заголовки для B (столбцы)
        matrix_header = tk.Frame(self.window)
        matrix_header.pack(pady=5)
        
        tk.Label(matrix_header, text="", width=8).grid(row=0, column=0)
        for j in range(cols):
            tk.Label(matrix_header, text=f"b{j+1}", font=("Arial", 8, "bold"), width=8).grid(row=0, column=j+1)
        
        # Создаем фрейм для матрицы - |A| строк × |B| столбцов
        matrix_frame = tk.Frame(self.window)
        matrix_frame.pack(pady=5)
        
        self.matrix_entries = []
        for i in range(rows):  # по A (строки)
            tk.Label(matrix_frame, text=f"a{i+1}", font=("Arial", 8, "bold")).grid(row=i, column=0, padx=5, pady=2)
            row_entries = []
            for j in range(cols):  # по B (столбцы)
                entry = tk.Entry(matrix_frame, width=8)
                entry.grid(row=i, column=j+1, padx=2, pady=2)
                row_entries.append(entry)
            self.matrix_entries.append(row_entries)
        
        # ИСПРАВЛЕНО: Каждый СТОЛБЕЦ должен суммироваться в 1
        tk.Label(self.window, text="Каждый столбец должен суммироваться в 1", 
                font=("Arial", 8), fg="gray").pack()
        
        tk.Button(self.window, text="Рассчитать", command=self.calculate, bg="lightgreen", font=("Arial", 10)).pack(pady=15)
        tk.Button(self.window, text="Назад", command=self.back).pack()
        
    def calculate(self):
        try:
            # Парсим ансамбль B
            b_probs = []
            for j, entry in enumerate(self.b_entries):
                value = entry.get().strip()
                if not value:
                    raise ValueError(f"Введите вероятность P(b{j+1})")
                b_probs.append(float(value))
            
            if len(b_probs) != self.cols:
                raise ValueError(f"Ожидается {self.cols} значений для B")
            
            # Парсим матрицу условных вероятностей
            cond_probs = []
            for i in range(self.rows):  # по строкам A
                row = []
                for j in range(self.cols):  # по столбцам B
                    value = self.matrix_entries[i][j].get().strip()
                    if not value:
                        raise ValueError(f"Пустое значение в ячейке P(a{i+1}|b{j+1})")
                    row.append(float(value))
                cond_probs.append(row)
            
            # Проверяем корректность данных
            if abs(sum(b_probs) - 1.0) > 0.001:
                raise ValueError(f"Сумма вероятностей B должна быть равна 1 (получено {sum(b_probs):.4f})")
                
            # ИСПРАВЛЕНО: Проверяем суммы по СТОЛБЦАМ (для каждого b_j)
            for j in range(self.cols):
                col_sum = sum(cond_probs[i][j] for i in range(self.rows))
                if abs(col_sum - 1.0) > 0.001:
                    raise ValueError(f"Сумма условных вероятностей для b{j+1} должна быть равна 1 (получено {col_sum:.4f})")
            
            # Вызываем расчетный модуль
            results = calculate_from_variant2(b_probs, cond_probs)
            
            # Показываем результаты
            show_results(results)
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Некорректные данные: {str(e)}")
    
    def back(self):
        self.window.destroy()
        self.main_root.deiconify()

class InputWindow3:
    """Окно ввода для варианта 3: P(A,B)"""
    def __init__(self, main_root, rows, cols):
        self.main_root = main_root
        self.rows = rows
        self.cols = cols
        self.window = tk.Toplevel(main_root)
        self.window.title("Ввод данных: P(A,B)")
        self.window.geometry("700x600")
        
        # Совместные вероятности P(A,B)
        tk.Label(self.window, text="Совместные вероятности P(A,B):", 
                font=("Arial", 10, "bold")).pack(pady=10)
        
        # Заголовки для матрицы
        matrix_header = tk.Frame(self.window)
        matrix_header.pack(pady=5)
        
        tk.Label(matrix_header, text="", width=8).grid(row=0, column=0)
        for j in range(cols):
            tk.Label(matrix_header, text=f"b{j+1}", font=("Arial", 8, "bold"), width=8).grid(row=0, column=j+1)
        
        # Создаем фрейм для матрицы
        matrix_frame = tk.Frame(self.window)
        matrix_frame.pack(pady=5)
        
        self.matrix_entries = []
        for i in range(rows):
            tk.Label(matrix_frame, text=f"a{i+1}", font=("Arial", 8, "bold")).grid(row=i, column=0, padx=5, pady=2)
            row_entries = []
            for j in range(cols):
                entry = tk.Entry(matrix_frame, width=8)
                entry.grid(row=i, column=j+1, padx=2, pady=2)
                row_entries.append(entry)
            self.matrix_entries.append(row_entries)
        
        tk.Button(self.window, text="Рассчитать", command=self.calculate, bg="lightgreen", font=("Arial", 10)).pack(pady=15)
        tk.Button(self.window, text="Назад", command=self.back).pack()
        
    def calculate(self):
        try:
            # Парсим матрицу совместных вероятностей
            joint_probs = []
            for i in range(self.rows):
                row = []
                for j in range(self.cols):
                    value = self.matrix_entries[i][j].get().strip()
                    if not value:
                        raise ValueError(f"Пустое значение в ячейке P(a{i+1},b{j+1})")
                    row.append(float(value))
                joint_probs.append(row)
            
            # Проверяем корректность данных
            total_sum = sum(sum(row) for row in joint_probs)
            if abs(total_sum - 1.0) > 0.001:
                raise ValueError(f"Сумма всех совместных вероятностей должна быть равна 1 (получено {total_sum:.4f})")
            
            # Вызываем расчетный модуль
            results = calculate_from_variant3(joint_probs)
            
            # Показываем результаты
            show_results(results)
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Некорректные данные: {str(e)}")
    
    def back(self):
        self.window.destroy()
        self.main_root.deiconify()

# Расчетные функции (остаются без изменений)
def calculate_from_variant1(a_probs, cond_probs):
    """Расчет всех величин из варианта 1: A, P(B|A)"""
    a_probs = np.array(a_probs)
    cond_probs = np.array(cond_probs)
    
    # Совместные вероятности P(A,B) = P(A) * P(B|A)
    joint_probs = a_probs.reshape(-1, 1) * cond_probs
    
    # Маргиналы B
    b_probs = np.sum(joint_probs, axis=0)
    
    # Условные P(A|B)
    a_given_b = joint_probs / b_probs
    a_given_b = np.nan_to_num(a_given_b)
    
    results = calculate_all_measures(a_probs, b_probs, joint_probs, cond_probs, a_given_b)
    return results

def calculate_from_variant2(b_probs, cond_probs):
    """Расчет всех величин из варианта 2: B, P(A|B)"""
    b_probs = np.array(b_probs)
    cond_probs = np.array(cond_probs)  # shape: (|A|, |B|)
    
    # Совместные вероятности P(A,B) = P(B) * P(A|B)
    # cond_probs имеет форму (rows, cols) = (|A|, |B|)
    # b_probs имеет форму (cols,) = (|B|,)
    # Нужно умножить каждый столбец cond_probs на соответствующий элемент b_probs
    joint_probs = cond_probs * b_probs  # broadcasting работает правильно
    
    # Маргиналы A
    a_probs = np.sum(joint_probs, axis=1)
    
    # Условные P(B|A)
    b_given_a = joint_probs / a_probs.reshape(-1, 1)
    b_given_a = np.nan_to_num(b_given_a)
    
    # Условные P(A|B) - это наши исходные cond_probs
    a_given_b = cond_probs
    
    results = calculate_all_measures(a_probs, b_probs, joint_probs, b_given_a, a_given_b)
    return results

def calculate_from_variant3(joint_probs):
    """Расчет всех величин из варианта 3: P(A,B)"""
    joint_probs = np.array(joint_probs)
    
    a_probs = np.sum(joint_probs, axis=1)
    b_probs = np.sum(joint_probs, axis=0)
    
    b_given_a = joint_probs / a_probs.reshape(-1, 1)
    b_given_a = np.nan_to_num(b_given_a)
    
    a_given_b = joint_probs / b_probs
    a_given_b = np.nan_to_num(a_given_b)
    
    results = calculate_all_measures(a_probs, b_probs, joint_probs, b_given_a, a_given_b)
    return results

def calculate_all_measures(a_probs, b_probs, joint_probs, cond_ba, cond_ab):
    """Вычисление всех информационных мер"""
    h_a = -np.sum(a_probs * np.log2(a_probs, where=(a_probs>0)))
    h_b = -np.sum(b_probs * np.log2(b_probs, where=(b_probs>0)))
    h_ab = -np.sum(joint_probs * np.log2(joint_probs, where=(joint_probs>0)))
    h_b_given_a = -np.sum(joint_probs * np.log2(cond_ba, where=(cond_ba>0)))
    h_a_given_b = -np.sum(joint_probs * np.log2(cond_ab, where=(cond_ab>0)))
    i_ab = h_a - h_a_given_b
    
    return {
        'a_probs': a_probs,
        'b_probs': b_probs, 
        'joint_probs': joint_probs,
        'cond_ba': cond_ba,
        'cond_ab': cond_ab,
        'h_a': h_a,
        'h_b': h_b,
        'h_ab': h_ab,
        'h_b_given_a': h_b_given_a,
        'h_a_given_b': h_a_given_b,
        'i_ab': i_ab
    }

def show_results(results):
    """Окно с результатами"""
    result_window = tk.Toplevel()
    result_window.title("Результаты расчетов")
    result_window.geometry("700x600")
    
    text = tk.Text(result_window, wrap=tk.WORD)
    scrollbar = tk.Scrollbar(result_window, command=text.yview)
    text.configure(yscrollcommand=scrollbar.set)
    
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    output = f"""Результаты:

Ансамбль A: {', '.join(f'{p:.4f}' for p in results['a_probs'])}
Ансамбль B: {', '.join(f'{p:.4f}' for p in results['b_probs'])}
Энтропия H(A): {results['h_a']:.4f}
Энтропия H(B): {results['h_b']:.4f}
Условная энтропия H(B|A): {results['h_b_given_a']:.4f}
Условная энтропия H(A|B): {results['h_a_given_b']:.4f}
Совместная энтропия H(AB): {results['h_ab']:.4f}
Взаимная информация I(A;B): {results['i_ab']:.4f}

Совместные вероятности P(A,B):
"""
    # Вывод совместных вероятностей в виде матрицы
    joint_matrix = results['joint_probs']
    rows, cols = joint_matrix.shape
    
    # Простой вывод матрицы без заголовков
    for i in range(rows):
        row_str = " ".join(f"{joint_matrix[i,j]:7.4f}" for j in range(cols)) + "\n"
        output += row_str
    
    output += "\nУсловные вероятности P(b|a):\n"
    cond_ba_matrix = results['cond_ba']
    for i in range(cond_ba_matrix.shape[0]):
        row_str = " ".join(f"{p:7.4f}" for p in cond_ba_matrix[i]) + "\n"
        output += row_str
    
    output += "\nУсловные вероятности P(a|b):\n"
    cond_ab_matrix = results['cond_ab']
    for i in range(cond_ab_matrix.shape[0]):
        row_str = " ".join(f"{p:7.4f}" for p in cond_ab_matrix[i]) + "\n"
        output += row_str
    
    text.insert(tk.END, output)
    text.config(state=tk.DISABLED)

# Запуск приложения
if __name__ == "__main__":
    root = tk.Tk()
    app = MainApp(root)
    root.mainloop()
